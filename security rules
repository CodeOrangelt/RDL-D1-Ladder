rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // --- Helper Functions ---

    // Checks admin emails (replace with your actual list)
    function isAdminEmail() {
      // Ensure request.auth is not null before accessing token.email
      return request.auth != null && request.auth.token.email in ['admin@ladder.com', 'brian2af@outlook.com'];
    }

    // Checks user profile for specific roles
    function hasRole(userId, allowedRoles) {
      let profilePath = /databases/$(database)/documents/userProfiles/$(userId);
      // Check existence first.
      return exists(profilePath) &&
             // Directly access data and perform checks if profile exists
             (
               // Calculate effective role directly using safe gets and ternary operator
               (
                 (get(profilePath).data.get('roleName', '') != '' ?
                  get(profilePath).data.get('roleName', '') :
                  get(profilePath).data.get('role', '')
                 )
                 .lower() // Convert the chosen role to lower case
               )
               // Check if the effective role is in the allowed list
               in allowedRoles
             );
    }

    // Function to check if user can manage articles
    function canManageArticles(userId) {
      // Allow if user is admin by email OR has specific roles in their profile
      // Ensure request.auth is not null before checking email or roles
      return request.auth != null && (isAdminEmail() || hasRole(userId, ['admin', 'owner', 'creative lead']));
    }

    // --- Collections ---

    // Articles Collection
    match /articles/{articleId} {
      // Anyone can read articles
      allow read: if true;
      // Only authorized roles can create, update, delete
      allow create, update, delete: if request.auth != null && canManageArticles(request.auth.uid);
    }

    // User Profiles Collection
    match /userProfiles/{userId} {
      allow read: if true;
      allow create: if request.auth != null && request.auth.uid == userId;
      allow update: if request.auth != null && (request.auth.uid == userId || canManageArticles(request.auth.uid));
      allow delete: if request.auth != null && isAdminEmail();
    }

    // --- Your Existing Rules ---

    // isAdmin function (Consider removing if isAdminEmail is sufficient)
    function isAdmin() {
      // Ensure request.auth check
      return request.auth != null && request.auth.token.email in ['admin@ladder.com', 'brian2af@outlook.com'];
    }

    // Function to check if a user is signed in (used by other rules)
    function isSignedIn() {
      return request.auth != null;
    }

    // isVerifiedUser function (Identical to isSignedIn, consider removing if not specifically needed elsewhere)
    function isVerifiedUser() {
      return request.auth != null;
    }

    // --- Existing Match Blocks ---
    match /players/{playerId} {
      allow read: if true;
      allow create: if request.auth != null;
      // Ensure request.auth != null for all parts of update rule
      allow update: if request.auth != null && (
        isAdmin() || // isAdmin() already checks request.auth
        request.auth.uid == playerId ||
        request.resource.data.diff(resource.data).affectedKeys()
          .hasOnly(['eloRating', 'lastMatchDate', 'position', 'lastMatchId', 'wins', 'losses'])
      );
      allow delete: if request.auth != null && (request.auth.uid == playerId || isAdmin());
    }

    match /playersD2/{playerId} {
      allow read: if true;
      allow create: if request.auth != null;
      allow update: if request.auth != null; // Consider more specific rules
      allow delete: if request.auth != null && (request.auth.uid == playerId || isAdmin());
    }

    match /playersD3/{playerId} {
      allow read: if true;
      allow create: if isVerifiedUser(); // isVerifiedUser checks request.auth
      allow update: if request.auth != null && ( // Ensure outer request.auth check
                   isAdmin() ||
                   request.auth.uid == playerId ||
                   (request.resource.data.diff(resource.data).affectedKeys()
                    .hasAll(['eloRating', 'lastMatchDate', 'position'])) ||
                   (isAdmin() &&
                    request.resource.data.diff(resource.data).affectedKeys()
                    .hasAny(['eloRating', 'lastPromotedAt', 'promotedBy']))
                   );
      allow delete: if isAdmin();
    }

    match /playersDuos/{playerId} {
      allow read: if true;
      allow create: if isVerifiedUser();
      allow update: if request.auth != null && ( // Ensure outer request.auth check
                   isAdmin() ||
                   request.auth.uid == playerId ||
                   (request.resource.data.diff(resource.data).affectedKeys()
                    .hasAll(['eloRating', 'lastMatchDate', 'position'])) ||
                   (isAdmin() &&
                    request.resource.data.diff(resource.data).affectedKeys()
                    .hasAny(['eloRating', 'lastPromotedAt', 'promotedBy']))
                   );
      allow delete: if isAdmin();
    }

    match /playersCTF/{playerId} {
      allow read: if true;
      allow create: if isVerifiedUser();
      allow update: if request.auth != null && ( // Ensure outer request.auth check
                   isAdmin() ||
                   request.auth.uid == playerId ||
                   (request.resource.data.diff(resource.data).affectedKeys()
                    .hasAll(['eloRating', 'lastMatchDate', 'position'])) ||
                   (isAdmin() &&
                    request.resource.data.diff(resource.data).affectedKeys()
                    .hasAny(['eloRating', 'lastPromotedAt', 'promotedBy']))
                   );
      allow delete: if isAdmin();
    }

    match /nonParticipants/{userId} {
      allow read: if true;
      allow create: if isVerifiedUser();
      allow update: if request.auth != null && (isAdmin() || request.auth.uid == userId);
      allow delete: if isAdmin();
    }

    match /pendingRegistrations/{registrationId} {
      allow read: if true;
      allow create: if request.auth != null;
      allow update: if request.auth != null &&
                   (request.auth.uid == registrationId || isAdmin());
      allow delete: if isAdmin();
    }

    match /nexus_users/{userId} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && request.auth.uid == userId;
    }

    match /player-status/{document=**} {
      allow read: if true;
      allow write: if request.auth != null;
    }

    match /invites/{userId} {
      allow read, write: if true; // Consider restricting write access
    }

    match /processedMatches/{matchId} {
      allow read, write: if request.auth != null; // Consider restricting write access
    }

    match /readyPlayers/{userId} {
      allow read, write: if true; // Consider restricting write access
    }

    match /playerStats/{userId} {
      allow read: if true;
      allow write: if isSignedIn() && // isSignedIn checks request.auth
        (request.auth.uid == userId || isAdmin());
    }

    match /system/{document} {
      allow read, write: if true; // Consider restricting write access, maybe only isAdmin()
    }

    match /pendingMatches/{matchId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null;
      // Allow update/delete only by participants or admin?
      allow update, delete: if request.auth != null; // Consider more specific rules
    }

    match /approvedMatches/{matchId} {
      allow read: if true;
      allow create: if request.auth != null; // Should only admin create approved matches?
      allow update, delete: if isAdmin();
    }

    match /pendingMatchesD2/{matchId} {
      allow read: if true; // Should this be request.auth != null?
      allow create: if request.auth != null;
      allow update, delete: if request.auth != null; // Consider more specific rules
    }

    match /approvedMatchesD2/{matchId} {
      allow read: if true;
      allow create, update: if request.auth != null; // Should only admin create/update approved?
      allow delete: if isAdmin();
    }

    match /eloHistoryD2/{document=**} {
      allow read: if true;
      allow write: if request.auth != null; // Should only admin write history?
    }

    match /pendingMatchesD3/{matchId} {
      allow read: if true; // Should this be request.auth != null?
      allow create: if request.auth != null;
      allow update, delete: if request.auth != null; // Consider more specific rules
    }

    match /approvedMatchesD3/{matchId} {
      allow read: if true;
      allow create, update: if request.auth != null; // Should only admin create/update approved?
      allow delete: if false; // Explicitly disallowed
    }

    match /pendingMatchesDuos/{matchId} {
      allow read: if true; // Should this be request.auth != null?
      allow create: if request.auth != null;
      allow update, delete: if request.auth != null; // Consider more specific rules
    }

    match /approvedMatchesDuos/{matchId} {
      allow read: if true;
      allow create, update: if request.auth != null; // Should only admin create/update approved?
      allow delete: if false; // Explicitly disallowed
    }

    match /pendingMatchesCTF/{matchId} {
      allow read: if true; // Should this be request.auth != null?
      allow create: if request.auth != null;
      allow update, delete: if request.auth != null; // Consider more specific rules
    }

    match /approvedMatchesCTF/{matchId} {
      allow read: if true;
      allow create, update: if request.auth != null; // Should only admin create/update approved?
      allow delete: if false; // Explicitly disallowed
    }

    match /eloHistory/{historyId} {
      allow read: if true;
      allow create: if request.auth != null; // Should only admin create history?
      allow update, delete: if isAdmin();
    }

    match /retroTracker/{docId} {
      allow read: if true;
      allow create: if request.auth != null &&
                   request.resource.data.keys().hasAll([
                     'gameName', 'players', 'timestamp'
                   ]);
      allow write: if request.auth != null; // Consider restricting write access
    }

    match /metadata/seasonCount {
      allow read: if true;
      allow write: if isAdmin();
    }

    match /seasons/{seasonId} {
      allow read: if true;
      allow write: if isAdmin();
    }

    match /promotionViews/{docId} {
      allow read: if request.auth != null;
      // Ensure request.auth.token.email is not null before split
      allow write: if request.auth != null &&
                   request.auth.token.email != null &&
                   docId.matches('promotion_.*_' + request.auth.token.email.split('@')[0]) &&
                   request.resource.data.keys().hasAll(['promotionId', 'playerName', 'views', 'createdAt', 'updatedAt']) &&
                   request.resource.data.views is number &&
                   request.resource.data.views <= 3 &&
                   request.resource.data.createdAt is timestamp &&
                   request.resource.data.updatedAt is timestamp;
    }

    match /season0/{document=**} {
      allow read: if request.auth != null;
      allow write: if isAdmin();
    }

    match /season0records/{document} {
      allow read: if request.auth != null;
      allow write: if isAdmin() &&
                  request.resource.data.keys().hasAll(['records', 'archivedAt']) &&
                  request.resource.data.records is list;
    }

    match /promotionHistory/{document} {
      allow read: if request.auth != null;
      allow create: if request.auth != null && (
        (
          request.resource.data.keys().hasAll(['username', 'rank', 'timestamp']) &&
          request.resource.data.timestamp is timestamp &&
          request.resource.data.username is string &&
          request.resource.data.rank is string
        ) ||
        (
          request.resource.data.keys().hasAll([
            'username', 'userId', 'previousElo', 'newElo',
            'previousRank', 'newRank', 'timestamp', 'type'
          ]) &&
          request.resource.data.timestamp is timestamp &&
          request.resource.data.previousElo is number &&
          request.resource.data.newElo is number &&
          request.resource.data.type in ['promotion', 'demotion']
        )
      );
      allow update, delete: if false; // Explicitly disallowed
    }

    match /users/{userId} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && request.auth.uid == userId;
    }

    match /notifiedMatches/{matchId} {
      allow read, write: if true; // Consider restricting write access
    }

    match /RejectedD1/{matchId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null && (
        request.resource.data.winnerId == request.auth.uid ||
        request.resource.data.winnerEmail == request.auth.token.email ||
        // Safely check player existence before getting data
        (exists(/databases/$(database)/documents/players/$(request.auth.uid)) &&
         request.resource.data.winnerUsername == get(/databases/$(database)/documents/players/$(request.auth.uid)).data.username) ||
        isAdmin()
      );
      allow update, delete: if isAdmin();
    }

    match /RejectedD2/{matchId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null && (
        request.resource.data.winnerId == request.auth.uid ||
        request.resource.data.winnerEmail == request.auth.token.email ||
        // Safely check player existence before getting data
        (exists(/databases/$(database)/documents/playersD2/$(request.auth.uid)) &&
         request.resource.data.winnerUsername == get(/databases/$(database)/documents/playersD2/$(request.auth.uid)).data.username) ||
        isAdmin()
      );
      allow update, delete: if isAdmin();
    }

  } // Closing brace for match /databases/{database}/documents
} // Closing brace for service cloud.firestore
// NO CHARACTERS OR BRACES BELOW THIS LINE