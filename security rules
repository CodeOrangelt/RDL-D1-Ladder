rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // --- Helper Functions ---

    // Checks admin emails
    function isAdminEmail() {
      return request.auth != null && request.auth.token.email in ['admin@ladder.com', 'brian2af@outlook.com'];
    }

    // Function to safely get role from a path (Moved outside hasRole)
    // Note: Firestore rules don't support nested function definitions like this.
    // We will integrate this logic directly into hasRole or keep it separate if needed elsewhere.
    // For now, let's integrate it.

    // Checks user profile for specific roles - UPDATED to check multiple collections
    function hasRole(userId, allowedRoles) {
      // Define paths
      let profilePath = /databases/$(database)/documents/userProfiles/$(userId);
      let playerD1Path = /databases/$(database)/documents/players/$(userId);
      let playerD2Path = /databases/$(database)/documents/playersD2/$(userId);

      // Get roles safely, prioritizing roleName over role
      let roleFromProfile = exists(profilePath) ? (get(profilePath).data.get('roleName', '') != '' ? get(profilePath).data.get('roleName', '') : get(profilePath).data.get('role', '')).lower() : '';
      let roleFromD1 = exists(playerD1Path) ? (get(playerD1Path).data.get('roleName', '') != '' ? get(playerD1Path).data.get('roleName', '') : get(playerD1Path).data.get('role', '')).lower() : '';
      let roleFromD2 = exists(playerD2Path) ? (get(playerD2Path).data.get('roleName', '') != '' ? get(playerD2Path).data.get('roleName', '') : get(playerD2Path).data.get('role', '')).lower() : '';

      // Determine the effective role based on priority
      let effectiveRole = roleFromProfile != '' ? roleFromProfile :
                          roleFromD1 != '' ? roleFromD1 :
                          roleFromD2; // roleFromD2 can be '' if not found

      // Check if the effective role is in the allowed list
      return effectiveRole in allowedRoles;
    }

    // Function to check if user can manage articles - uses updated hasRole
    function canManageArticles(userId) {
      return request.auth != null && (isAdminEmail() || hasRole(userId, ['admin', 'owner', 'creative lead']));
    }

    // Function to check if user can manage trophies - uses updated hasRole
    function canManageTrophies(userId) {
      return request.auth != null && (isAdminEmail() || hasRole(userId, ['admin', 'owner', 'creative lead']));
    }

    // --- Collections ---

    // Articles Collection
    match /articles/{articleId} {
      allow read: if true;
      allow create, update, delete: if request.auth != null && canManageArticles(request.auth.uid);
    }

    // User Profiles Collection
    match /userProfiles/{userId} {
      allow read: if true;
      allow create: if request.auth != null && request.auth.uid == userId;
      // Allow update by self or someone who can manage articles (which includes admins/creative leads)
      allow update: if request.auth != null && (request.auth.uid == userId || canManageArticles(request.auth.uid));
      allow delete: if request.auth != null && isAdminEmail();
    }

    // Match Comments Collection
    match /matchComments/{commentId} {
      allow read: if true;
      allow create: if request.auth != null &&
                     request.resource.data.userId == request.auth.uid &&
                     request.resource.data.keys().hasAll(['matchId', 'userId', 'username', 'text', 'timestamp']);
      // Allow update only by the original author
      // Use resource (existing data) not request.resource (incoming data) for ownership check
      allow update: if request.auth != null &&
                     resource.data.userId == request.auth.uid;
      // Allow deletion by the original author or admins (using isAdminEmail)
      allow delete: if request.auth != null &&
                     (resource.data.userId == request.auth.uid || isAdminEmail());
    }

    // Trophy Definitions Collection
    match /trophyDefinitions/{trophyId} {
      allow read: if true;
      allow create, update, delete: if request.auth != null && canManageTrophies(request.auth.uid);
    }

    // User Trophies Collection
    match /userTrophies/{trophyId} {
      allow read: if true;
      // Allow create/update by admins or the awarding user (check email)
      allow create, update: if request.auth != null &&
                              (isAdminEmail() ||
                               (request.auth.token.email != null && request.auth.token.email == request.resource.data.awardedBy)); // Ensure email exists before comparing
      allow delete: if request.auth != null && isAdminEmail();
    }

    // --- Your Existing Helper Functions (Simplified) ---

    // isAdmin function (Redundant if isAdminEmail is used consistently)
    // function isAdmin() {
    //   return request.auth != null && request.auth.token.email in ['admin@ladder.com', 'brian2af@outlook.com'];
    // }

    // Function to check if a user is signed in
    function isSignedIn() {
      return request.auth != null;
    }

    // isVerifiedUser function (Redundant, same as isSignedIn)
    // function isVerifiedUser() {
    //   return request.auth != null;
    // }

    // --- Player Collections ---
    match /players/{playerId} {
      allow read: if true;
      allow create: if isSignedIn(); // Use helper function
      allow update: if isSignedIn() && (
        isAdminEmail() ||
        request.auth.uid == playerId ||
        // Allow specific fields update for match processing
        request.resource.data.diff(resource.data).affectedKeys()
          .hasOnly(['eloRating', 'lastMatchDate', 'position', 'lastMatchId', 'wins', 'losses'])
      );
      allow delete: if isSignedIn() && (request.auth.uid == playerId || isAdminEmail());
    }

    match /playersD2/{playerId} {
      allow read: if true;
      allow create: if isSignedIn();
      // More specific update rule needed here - currently allows any signed-in user to update anything
      allow update: if isSignedIn() && (isAdminEmail() || request.auth.uid == playerId); // Example: Allow self or admin
      allow delete: if isSignedIn() && (request.auth.uid == playerId || isAdminEmail());
    }

    match /playersD3/{playerId} {
      allow read: if true;
      allow create: if isSignedIn(); // Use helper function
      allow update: if isSignedIn() && (
                   isAdminEmail() ||
                   request.auth.uid == playerId ||
                   // Allow specific fields update for match processing
                   request.resource.data.diff(resource.data).affectedKeys()
                    .hasAny(['eloRating', 'lastMatch', 'wins', 'losses', 'lastEloChange', 'position'])
                   );
      allow delete: if isSignedIn() && (request.auth.uid == playerId || isAdminEmail());
    }

    match /playersDuos/{playerId} {
      allow read: if true;
      allow create: if isSignedIn();
      allow update: if isSignedIn() && (
                   isAdminEmail() ||
                   request.auth.uid == playerId ||
                   // Allow specific fields update for match processing
                   (request.resource.data.diff(resource.data).affectedKeys()
                    .hasAll(['eloRating', 'lastMatchDate', 'position'])) ||
                   // Allow admin to update promotion fields
                   (isAdminEmail() &&
                    request.resource.data.diff(resource.data).affectedKeys()
                    .hasAny(['eloRating', 'lastPromotedAt', 'promotedBy']))
                   );
      allow delete: if isAdminEmail(); // Only admin can delete Duos players? Adjust if needed.
    }

    match /playersCTF/{playerId} {
      allow read: if true;
      allow create: if isSignedIn();
      allow update: if isSignedIn() && (
                   isAdminEmail() ||
                   request.auth.uid == playerId ||
                   // Allow specific fields update for match processing
                   (request.resource.data.diff(resource.data).affectedKeys()
                    .hasAll(['eloRating', 'lastMatchDate', 'position'])) ||
                   // Allow admin to update promotion fields
                   (isAdminEmail() &&
                    request.resource.data.diff(resource.data).affectedKeys()
                    .hasAny(['eloRating', 'lastPromotedAt', 'promotedBy']))
                   );
      allow delete: if isAdminEmail(); // Only admin can delete CTF players? Adjust if needed.
    }

    // --- Other Collections (Review Permissions) ---

    match /nonParticipants/{userId} {
      allow read: if true;
      allow create: if isSignedIn();
      allow update: if isSignedIn() && (isAdminEmail() || request.auth.uid == userId);
      allow delete: if isAdminEmail();
    }

    match /pendingRegistrations/{registrationId} {
      allow read: if true; // Should admin also be able to read?
      allow create: if isSignedIn();
      // Allow update by the user who created it (assuming registrationId == userId) or admin
      allow update: if isSignedIn() &&
                   (request.auth.uid == registrationId || isAdminEmail());
      allow delete: if isAdminEmail();
    }

    // Deprecated? Consider removing if not used
    match /nexus_users/{userId} {
      allow read: if isSignedIn();
      allow write: if isSignedIn() && request.auth.uid == userId;
    }

    match /player-status/{document=**} {
      allow read: if true;
      allow write: if isSignedIn(); // Any signed-in user can write to any status? Be careful.
    }

    match /invites/{userId} {
      allow read, write: if true; // VERY open. Any user can read/write any invite. Restrict this.
      // Example restriction: allow read, write: if isSignedIn() && request.auth.uid == userId;
    }

    match /processedMatches/{matchId} {
      allow read, write: if isSignedIn(); // Any signed-in user can write? Restrict to admin or system process.
      // Example restriction: allow read: if isSignedIn(); allow write: if isAdminEmail();
    }

    match /readyPlayers/{userId} {
      allow read, write: if true; // VERY open. Restrict this.
      // Example restriction: allow read, write: if isSignedIn() && request.auth.uid == userId;
    }

    match /playerStats/{userId} {
      allow read: if true;
      allow write: if isSignedIn() &&
        (request.auth.uid == userId || isAdminEmail());
    }

    match /system/{document} {
      allow read, write: if true; // VERY open. Restrict write access.
      // Example restriction: allow read: if true; allow write: if isAdminEmail();
    }

    // --- Match Collections (D1) ---
    match /pendingMatches/{matchId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn();
      // Allow update/delete by participants or admin
      allow update, delete: if isSignedIn() &&
                             (isAdminEmail() ||
                              resource.data.winnerId == request.auth.uid ||
                              resource.data.loserId == request.auth.uid); // Check existing doc for participants
    }

    match /approvedMatches/{matchId} {
      allow read: if true;
      // Only admin should create/update/delete approved matches
      allow create, update, delete: if isAdminEmail();
    }

    // --- Match Collections (D2) ---
    match /pendingMatchesD2/{matchId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn();
      allow update, delete: if isSignedIn() &&
                             (isAdminEmail() ||
                              resource.data.winnerId == request.auth.uid ||
                              resource.data.loserId == request.auth.uid);
    }

    match /approvedMatchesD2/{matchId} {
      allow read: if true;
      allow create, update, delete: if isAdminEmail(); // Only admin
    }

    match /eloHistoryD2/{document=**} {
      allow read: if true;
      allow write: if isAdminEmail(); // Only admin should write history
    }

    // --- Match Collections (D3) ---
    match /eloHistoryD3/{document=**} {
      allow read: if true;
      allow write: if isAdminEmail(); // Only admin should write history
    }

    match /pendingMatchesD3/{matchId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn();
      allow update, delete: if isSignedIn() &&
                             (isAdminEmail() ||
                              resource.data.winnerId == request.auth.uid ||
                              resource.data.loserId == request.auth.uid);
    }

    match /approvedMatchesD3/{matchId} {
      allow read: if true;
      allow create, update: if isAdminEmail(); // Only admin
      allow delete: if false; // Explicitly disallowed
    }

    // --- Match Collections (Duos) ---
    match /pendingMatchesDuos/{matchId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn();
      allow update, delete: if isSignedIn(); // Needs refinement - check participants/admin
    }

    match /approvedMatchesDuos/{matchId} {
      allow read: if true;
      allow create, update: if isAdminEmail(); // Only admin
      allow delete: if false; // Explicitly disallowed
    }

    // --- Match Collections (CTF) ---
    match /pendingMatchesCTF/{matchId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn();
      allow update, delete: if isSignedIn(); // Needs refinement - check participants/admin
    }

    match /approvedMatchesCTF/{matchId} {
      allow read: if true;
      allow create, update: if isAdminEmail(); // Only admin
      allow delete: if false; // Explicitly disallowed
    }

    // --- Other History/Metadata ---
    match /eloHistory/{historyId} {
      allow read: if true;
      allow create, update, delete: if isAdminEmail(); // Only admin
    }

    match /retroTracker/{docId} {
      allow read: if true;
      // Allow create with specific fields
      allow create: if isSignedIn() &&
                   request.resource.data.keys().hasAll([
                     'gameName', 'players', 'timestamp'
                   ]);
      // Restrict general write access
      allow update, delete: if isAdminEmail(); // Example: Only admin can modify/delete
    }

    match /metadata/seasonCount {
      allow read: if true;
      allow write: if isAdminEmail();
    }

    match /seasons/{seasonId} {
      allow read: if true;
      allow write: if isAdminEmail();
    }

    match /promotionViews/{docId} {
      allow read: if isSignedIn();
      // Allow write only if docId matches user's email part and fields are correct
      allow write: if isSignedIn() &&
                   request.auth.token.email != null &&
                   docId.matches('promotion_.*_' + request.auth.token.email.split('@')[0]) &&
                   request.resource.data.keys().hasAll(['promotionId', 'playerName', 'views', 'createdAt', 'updatedAt']) &&
                   request.resource.data.views is number &&
                   request.resource.data.views <= 3 &&
                   request.resource.data.createdAt is timestamp &&
                   request.resource.data.updatedAt is timestamp;
    }

    match /season0/{document=**} {
      allow read: if isSignedIn();
      allow write: if isAdminEmail();
    }

    match /season0records/{document} {
      allow read: if isSignedIn();
      allow write: if isAdminEmail() &&
                  request.resource.data.keys().hasAll(['records', 'archivedAt']) &&
                  request.resource.data.records is list;
    }

    match /promotionHistory/{document} {
      allow read: if isSignedIn();
      // Allow creation with specific data structures
      allow create: if isSignedIn() && (
        (
          request.resource.data.keys().hasAll(['username', 'rank', 'timestamp']) &&
          request.resource.data.timestamp is timestamp &&
          request.resource.data.username is string &&
          request.resource.data.rank is string
        ) ||
        (
          request.resource.data.keys().hasAll([
            'username', 'userId', 'previousElo', 'newElo',
            'previousRank', 'newRank', 'timestamp', 'type'
          ]) &&
          request.resource.data.timestamp is timestamp &&
          request.resource.data.previousElo is number &&
          request.resource.data.newElo is number &&
          request.resource.data.type in ['promotion', 'demotion']
        )
      );
      allow update, delete: if false; // Explicitly disallowed
    }

    // Deprecated? Consider removing if not used
    match /users/{userId} {
      allow read: if isSignedIn();
      allow write: if isSignedIn() && request.auth.uid == userId;
    }

    match /notifiedMatches/{matchId} {
      allow read, write: if true; // VERY open. Restrict write access.
      // Example: allow read: if true; allow write: if isAdminEmail();
    }

    // --- Rejected Matches ---
    match /RejectedD1/{matchId} {
      allow read: if isSignedIn();
      // Allow create by winner or admin
      allow create: if isSignedIn() && (
        request.resource.data.winnerId == request.auth.uid ||
        (request.auth.token.email != null && request.resource.data.winnerEmail == request.auth.token.email) ||
        (exists(/databases/$(database)/documents/players/$(request.auth.uid)) &&
         request.resource.data.winnerUsername == get(/databases/$(database)/documents/players/$(request.auth.uid)).data.username) ||
        isAdminEmail()
      );
      allow update, delete: if isAdminEmail();
    }

    match /RejectedD2/{matchId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && (
        request.resource.data.winnerId == request.auth.uid ||
        (request.auth.token.email != null && request.resource.data.winnerEmail == request.auth.token.email) ||
        (exists(/databases/$(database)/documents/playersD2/$(request.auth.uid)) &&
         request.resource.data.winnerUsername == get(/databases/$(database)/documents/playersD2/$(request.auth.uid)).data.username) ||
        isAdminEmail()
      );
      allow update, delete: if isAdminEmail();
    }

    match /RejectedD3/{matchId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && (
        request.resource.data.winnerId == request.auth.uid ||
        (request.auth.token.email != null && request.resource.data.winnerEmail == request.auth.token.email) ||
        (exists(/databases/$(database)/documents/playersD3/$(request.auth.uid)) &&
        request.resource.data.winnerUsername == get(/databases/$(database)/documents/playersD3/$(request.auth.uid)).data.username) ||
        isAdminEmail()
      );
      allow update, delete: if isAdminEmail();
    }

  } // Closing brace for match /databases/{database}/documents
} // Closing brace for service cloud.firestore
// NO CHARACTERS OR BRACES BELOW THIS LINE